---
title: "Creating alerts"
linkTitle: "Creating alerts"
weight: 10
type: "docs"
draft: false
lang: "en"
---

A Prometheus Alert is one of two types of Prometheus Rules. To define an Alert, it is important to first understand the core components of a Rule: metrics and PromQL (Prometheus Query Language) queries.

### Metrics and Exporters

First and foremost, the relevant metrics must be available to Prometheus. If what you are trying to monitor with Prometheus has not been [instrumented](https://prometheus.io/docs/practices/instrumentation/) to natively expose metrics in a format that Prometheus can read, this requires creating or installing a metric exporter.

- [Sample list of exporters](https://prometheus.io/docs/instrumenting/exporters/)
- [Guide to writing exporters](https://prometheus.io/docs/instrumenting/writing_exporters/)

Whether the metrics are native or generated by an exporter, configurations must be put in place for them to be picked up. When using the [Prometheus Operator]({{< ref "/team/monitoring-surveillance/prometheus/prometheus-operator.en.md" >}}), such configurations can include creating or enabling ServiceMonitors or PodMonitors with labels that the Prometheus custom resource selects for.

### Querying metrics

Once metrics are available, developing a Prometheus query is the core of making a Prometheus Alert. Refer to the [Prometheus Documentation](https://prometheus.io/docs/prometheus/latest/querying/basics/) for understanding and building queries, and test them out by executing them in any running instance of Prometheus. 

Some metrics are useful for their values. Others are useful for their informative labels, and will typically have a "value" of 1. For any query with unique results for what is being measured, the [aggregation opperators](https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators) `sum by` and `sum without` are especially useful for trimming labels to return only relevant and secure information.

For example, the query `node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes` returns the available memory on nodes and is composed of two metrics made available by the Prometheus Node Exporter. A simple alert could correspond to the query `node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes * 100 < 15`. But the labels for these metrics only identify the node by its IP address (`instance`), which is not easy to follow. How could we get the node name instead? 

Fortunately, both the node `instance` and `nodename` are available in another metric, `node_uname_info`. Since `node_uname_info` is an informative label metric that always has a "value" of `1`, we can take advantage of the arithmetic operator `*` to join this information:  `node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes` **`* on(instance) group_left(nodename) node_uname_info`**.

Now we can use `sum by` to return only the `nodename`: **`sum by (nodename)`** `(node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes * on(instance,job) group_left(nodename) node_uname_info)`, perhaps with a * 100 < 15  at the end for an alert that will report on nodes under 15% memory. 

### Defining Prometheus Rules

There are two kinds of Prometheus Rules: **Records** and **Alerts**.

**Records** are very simple. They consist of a name and an expression corresponding to a query. This name can then be queried as if it was a metric, which is useful for organizing and pre-computing parts of complex queries.

For example:
- `sum(kube_node_status_allocatable_pods * on (node) group_left(label_agentpool) kube_node_labels) by (label_agentpool)` is recorded as `nodepool_allocatable_pods`
- `sum(kube_pod_info * on (node) group_left(label_agentpool) kube_node_labels) by (label_agentpool)` is recorded as `nodepool_allocated_pods`
- This simplifies constructing a query for the proportion of pods allocated in a nodepool into `nodepool_allocated_pods/nodepool_allocatable_pods`

**Alerts** also start with a name and an expression. However, the expression for an Alert will almost always end with some form of [comparison binary operator](https://prometheus.io/docs/prometheus/latest/querying/operators/#comparison-binary-operators), which is typically not the case for a Record.

Alerts are further defined by a duration, which is how long an expression must be valid for the alert to go from` Pending` to `Firing` (e.g. "less than 15% CPU left for more than 2 minutes"), any additional labels (such as `severity`), and any additional `annotations` such as a descriptive `message` and/or a `runbook` link.

#### Examples

Many examples of Prometheus Alerts are available at [Awesome Prometheus Alerts](https://awesome-prometheus-alerts.grep.to/). These alerts should be used as references and starting points: they assume the presence of any required exporters, do not omit any labels, and may have arbitrary thresholds, formats, and severities. For example, annotations are split into a `summary` and a `description` instead of a single `message`.

It is also important to calibrate the sensitivity of alerts to the scope and scale of the environment being monitored. The level of detail appropriate for monitoring a single application may be too noisy for the monitoring of a namespace, which can in turn be too noisy for the monitoring of one or more clusters.

### Picking up Prometheus Rules

Once Prometheus Rules are defined, they must be picked up by the relevant Prometheus instance.

In a standalone installation of Prometheus, rules are written in YAML files and which are specified under `rule_files` in the [Prometheus configuration](https://prometheus.io/docs/prometheus/latest/configuration/configuration/). The [Prometheus Helm chart](https://github.com/prometheus-community/helm-charts/tree/main/charts/prometheus) facilitates this by allowing the entry of rules as [Helm values](https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus/values.yaml) `alerting_rules.yml` and `recording_rules.yml`.

Alternatively, the [Prometheus Operator]({{< ref "/team/monitoring-surveillance/prometheus/prometheus-operator.en.md" >}}) facilitates the management of Prometheus Rules via a PrometheusRule Custom Resource Definition. There is no distinction made between Alerting and Recording rules, and they may coexist within the same PrometheusRule manifest.

A PrometheusRule custom resource defines one or more Prometheus Rules, which can further be categorized into groups. [See an example](https://github.com/frazs/prometheus-operator-configs/blob/master/general-cluster-alerts.yaml).

As with all other Kubernetes resources, PrometheusRules can be:
- Added with commands such as `kubectl -n mynamespace -f myalerts.yaml`
- Removed with `kubectl -n mynamespace delete prometheusrule my-alerts` (use `kubectl -n mynamespace get prometheusrules` to confirm the resource name)
- Updated by editing the yaml file and applying it again, whether manually or through any configuration-as-code management process.

The default configuration of the Prometheus instance installed by the [Kube-Prometheus-Stack Helm chart](https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack) (which installs the Prometheus Operator alongside supporting components) picks up all PrometheusRules with the label `release: kube-prometheus-stack`, or the name of the Helm release corresponding to kube-prometheus-stack if a different name was selected. This label must be on the PrometheusRule resource and should not be confused with labels on any Rules within.

This behaviour can be modified to look for one or more different labels, as well as to specify that PrometheusRules are only to be picked up from specific namespaces.

It is also possible to run multiple Prometheus instances with different criteria for which rules they pick up. These criteria are within the specification of the Prometheus custom resource(s) managed by the Prometheus Operator.
